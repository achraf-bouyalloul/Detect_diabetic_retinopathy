# -*- coding: utf-8 -*-
"""prdection_TOTAL_1234.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GtVpMOj4ivlHgBchgAa3RRbLF7O9gWrB
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
from keras.applications.densenet import preprocess_input
from keras.preprocessing import image
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.optimizers import Adam
from PIL import Image
import os
import matplotlib.pyplot as plt
from keras.applications import DenseNet121
from keras.models import Model
from keras.layers import Dense, GlobalAveragePooling2D
from keras.optimizers import Adam
from tensorflow.keras.applications.efficientnet import preprocess_input
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image

def dens(chemin,image_path):
  # Chargement et compilation du modèle DenseNet pour 5 classes
  input_shape = (224, 224, 3)
  base_model_dense = DenseNet121(weights='imagenet', include_top=False, input_shape=input_shape)
  x = base_model_dense.output
  x = GlobalAveragePooling2D()(x)
  x = Dense(512, activation='relu')(x)
  predictions_dense = Dense(5, activation='softmax')(x)
  model_dense = Model(inputs=base_model_dense.input, outputs=predictions_dense)
  model_dense.compile(optimizer=Adam(lr=0.001), loss='categorical_crossentropy', metrics=['accuracy'])
  model_dense.load_weights(chemin)

  # Chemin vers le dossier contenant les images à prédire

  image = Image.open(image_path)
  image = image.resize((input_shape[0], input_shape[1]))
  image_array = np.array(image)
  image_array = np.expand_dims(image_array, axis=0)
  image_array = image_array.astype('float32')
  image_array /= 255.0

  # Effectuer la prédiction
  predictions = model_dense.predict(image_array)
  predicted_class_index = np.argmax(predictions)
  #print(f"Image : {image_file},Classe prédite : {predicted_class_index}")
  p=int(predicted_class_index)
  return p


def eff(chemin,image_path):
  num_classes = 2
  input_shape = (224, 224, 3)

  # Chargement du modèle EfficientNetB0 pré-entraîné
  base_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=input_shape)

  # Ajout de nouvelles couches de classification
  x = base_model.output
  x = GlobalAveragePooling2D()(x)
  x = Dense(1024, activation='relu')(x)
  predictions = Dense(num_classes, activation='softmax')(x)
  model = Model(inputs=base_model.input, outputs=predictions)

  # Effectuer les prédictions pour chaque image dans le dossier

  image = Image.open(image_path)
  image = image.resize((input_shape[0], input_shape[1]))
  image_array = np.array(image)
  image_array = np.expand_dims(image_array, axis=0)
  image_array = image_array.astype('float32')
  image_array /= 255.0

  # Effectuer la prédiction
  predictions = model.predict(image_array)
  predicted_class_index = np.argmax(predictions)
  p=int(predicted_class_index)
  return p

chemin_densNET='chemin1' # choisi chemin de model DensNET121 filtre ou sans filtre
chemin_eff1_2='chemin2' # choisi chemin de model EfficientNETB0 qui trainer sur la classe 1 et 2
chemin_eff3_4='chemin3' # choisi chemin de model EfficientNETB0 qui trainer sur la classe 3 et 4
folder_path = 'chemin4' # choisi chemin de dossier qui contient les images

import os
import csv

# Liste des fichiers d'images dans le dossier
image_files = os.listdir(folder_path)

# Créer un fichier CSV pour enregistrer les résultats
csv_filename = 'predictions.csv'

with open(csv_filename, mode='w', newline='') as csv_file:
    fieldnames = ['image', 'level']
    writer = csv.DictWriter(csv_file, fieldnames=fieldnames)

    # Écrire les en-têtes dans le fichier CSV
    writer.writeheader()

    # Effectuer les prédictions pour chaque image dans le dossier
    for image_file in image_files:
        image_path = os.path.join(folder_path, image_file)
        pre = dens(chemin_densNET, image_path)
        if pre == 2:
            pre_1 = eff(chemin_eff1_2, image_path)
            if pre_1 == 0:
                writer.writerow({'image': image_file[:-4], 'level': 1})
                print("la predection de l'image",image_file,"est 1:")
            else:
                writer.writerow({'image': image_file[:-4], 'level': 2})
                print("la predection de l'image", image_file, "est 2:")
        elif pre == 3:
            pre_2 = eff(chemin_eff3_4, image_path)
            if pre_2 == 0:
                writer.writerow({'image': image_file[:-4], 'level': 3})
                print("la predection de l'image", image_file, "est 3:")
            else:
                writer.writerow({'image': image_file[:-4], 'level': 4})
                print("la predection de l'image", image_file, "est 4:")
        else:
            writer.writerow({'image': image_file[:-4], 'level': pre})

print("Prédictions enregistrées dans", csv_filename)