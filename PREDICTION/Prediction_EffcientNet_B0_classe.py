# -*- coding: utf-8 -*-
"""prediction_effcientnetB0_filtre.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iU61N9c1MJcExU1n8ancjoumIic6hREt
"""

from google.colab import drive
drive.mount('/content/drive')

import tensorflow as tf
from tensorflow.keras.applications import EfficientNetB0
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.models import Model
from tensorflow.keras.preprocessing.image import load_img, img_to_array
import numpy as np
import os

# Dimensions des images en entrée
input_shape = (224, 224)

# Nombre de classes dans votre ensemble de données
num_classes = 2

# Créer le modèle EfficientNetB5 pré-entraîné sans la couche de classification finale
base_model = EfficientNetB0(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Ajouter une nouvelle couche de classification adaptée à votre tâche
x = GlobalAveragePooling2D()(base_model.output)
output = Dense(num_classes, activation='softmax')(x)

# Créer le modèle final
model = Model(inputs=base_model.input, outputs=output)

# Charger les poids du modèle entraîné
model.load_weights('/content/drive/MyDrive/the_best_model/model_trained_effcientNET_3_4.h5')

# Chemin vers le dossier contenant les images à prédire
folder_path = '/content/drive/MyDrive/class_processed/4'

# Liste des fichiers d'images dans le dossier
image_files = os.listdir(folder_path)
# Effectuer les prédictions pour chaque image dans le dossier
for image_file in image_files:
    image_path = os.path.join(folder_path, image_file)
    # Charger l'image, la redimensionner à la taille d'entrée et la prétraiter
    image = load_img(image_path, target_size=input_shape)
    image_array = img_to_array(image)
    image_array = image_array / 255.0  # Mise à l'échelle des pixels entre 0 et 1
    image_array = np.expand_dims(image_array, axis=0)  # Ajouter une dimension pour le batch

    # Effectuer la prédiction
    predictions = model.predict(image_array)

    # Les prédictions seront un tableau numpy contenant les probabilités d'appartenance à chaque classe
    # Vous pouvez utiliser la fonction argmax pour obtenir l'indice de la classe prédite avec la plus haute probabilité
    predicted_class_index = np.argmax(predictions)
    print(f"Image : {image_file}, Probabilités des classes : {predictions[0]}, Classe prédite : {predicted_class_index}")